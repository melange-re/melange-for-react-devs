import{_ as e,o as t,c as o,Q as a}from"./chunks/framework.0e8ae64e.js";const f=JSON.parse('{"title":"Melange for React Developers","description":"","frontmatter":{},"headers":[],"relativePath":"intro/index.md","filePath":"intro/index.md","lastUpdated":1733333871000}'),r={name:"intro/index.md"},n=a('<h1 id="melange-for-react-developers" tabindex="-1">Melange for React Developers <a class="header-anchor" href="#melange-for-react-developers" aria-label="Permalink to &quot;Melange for React Developers&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>This is a work in progress.</p><p>We’d love to hear your feedback! If you find any errors or have suggestions for the book, please <a href="https://github.com/ahrefs/melange-for-react-devs/issues" target="_blank" rel="noreferrer">file an issue</a> or ping @feihong on the <a href="https://discord.gg/reasonml" target="_blank" rel="noreferrer">#melange channel in the Reason Discord</a>.</p></div><h2 id="what-is-melange" tabindex="-1">What is Melange? <a class="header-anchor" href="#what-is-melange" aria-label="Permalink to &quot;What is Melange?&quot;">​</a></h2><p>Melange is a collection of tools that bring the robustness of a mature, statically-typed multi-paradigm programming language to the JavaScript ecosystem. That language is OCaml, a language invented in the 1990s which has been battle-tested by industry stalwarts. The heart of Melange is (1) a compiler that translates OCaml to human-readable JavaScript and (2) built-in language constructs for zero-cost interoperation with JavaScript.</p><h2 id="why-ocaml" tabindex="-1">Why OCaml? <a class="header-anchor" href="#why-ocaml" aria-label="Permalink to &quot;Why OCaml?&quot;">​</a></h2><p>OCaml codebases scale well both in terms of quantity of lines and number of contributors. The sound type system helps to prevent ambiguous behavior in your program—if it compiles, it runs without runtime errors. OCaml and React (via <a href="https://reasonml.github.io/reason-react/" target="_blank" rel="noreferrer">ReasonReact</a>) are an effective, FP-friendly combination for building frontend UIs using JSX syntax. If the backend is also written in OCaml, you can share types between the frontend and backend, ensuring that they stay in sync<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. It’s even possible to write <a href="https://github.com/ml-in-barcelona/server-reason-react" target="_blank" rel="noreferrer">universal React components</a> that are rendered on the server with the performance of native code<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><h2 id="what-s-in-this-book" tabindex="-1">What’s in this book <a class="header-anchor" href="#what-s-in-this-book" aria-label="Permalink to &quot;What&#39;s in this book&quot;">​</a></h2><p>This is a project-based, guided introduction to Melange and its ecosystem. Because Melange uses both OCaml and JavaScript ecosystems, there are quite a few tools and concepts to learn. Therefore we try to make each chapter small and digestible, not introducing too many things at once.</p><h2 id="audience" tabindex="-1">Audience <a class="header-anchor" href="#audience" aria-label="Permalink to &quot;Audience&quot;">​</a></h2><p>You should already know how to make frontend applications in JavaScript, in particular with <a href="https://react.dev/" target="_blank" rel="noreferrer">React</a>. You should be interested in learning how to leverage your existing knowledge to build apps using <a href="https://reasonml.github.io/reason-react/" target="_blank" rel="noreferrer">ReasonReact</a>. You do not need to know OCaml<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>—we’ll slowly introduce the basics of the language throughout the tutorial. That said, a good complement to this guide is <a href="https://cs3110.github.io/textbook/" target="_blank" rel="noreferrer">OCaml Programming: Correct + Efficient + Beautiful</a>, which teaches the language from the ground up and goes much deeper into its features.</p><h2 id="chapters-and-topics" tabindex="-1">Chapters and topics <a class="header-anchor" href="#chapters-and-topics" aria-label="Permalink to &quot;Chapters and topics&quot;">​</a></h2><table><thead><tr><th>Title</th><th>Summary</th><th>Topics covered</th></tr></thead><tbody><tr><td>Counter</td><td>Number that can be incremented or decremented</td><td>module, Option, <code>React.string</code>, pipe last operator, function chaining, switch expression</td></tr><tr><td>Numeric Types</td><td>Use Melange Playground to explore OCaml’s numeric types</td><td>Int, Float, Playground, sharing snippets, comparison operators, arithmetic operators, widgets in Playground</td></tr><tr><td>Celsius Converter</td><td>Single input that converts from Celsius to Fahrenheit</td><td><code>Js.t</code> object, string concatenation (<code>++</code>), exception handling, ternary expression, if-else expression, labeled argument, partial application, <code>{js||js}</code> quoted string literal</td></tr><tr><td>Celsius Converter Using Option</td><td>The same component from the last chapter but replacing exception handling with Option</td><td>Option, <code>Option.map</code>, <code>when</code> guard</td></tr><tr><td>Introduction to Dune</td><td>A introduction to the Dune build system</td><td><code>dune-project</code> file, <code>dune</code> file, <code>melange.emit</code> stanza, monorepo structure</td></tr><tr><td>Order Confirmation</td><td>An order confirmation for a restaurant website</td><td>variant type, primary type of module (<code>t</code>), wildcard (<code>_</code>) in switch, <code>fun</code> syntax, <code>Js.Array</code> functions, <code>React.array</code>, type transformation functions</td></tr><tr><td>Styling with CSS</td><td>Styling the order confirmation using CSS</td><td><code>mel.raw</code> extension node, <code>runtime_deps</code> field, <code>glob_files</code> term, <code>external</code>, <code>mel.module</code> attribute</td></tr><tr><td>Better Sandwiches</td><td>Support different kinds of sandwiches by adding constructor arguments</td><td>variant constructor argument, variant pattern matching, <code>{j||j}</code> quoted string literal, <code>Printf.sprintf</code>, building bundles</td></tr><tr><td>Better Burgers</td><td>Support different toppings for burgers by using records</td><td>record type, record destructuring, record pattern matching, submodules, wildcard</td></tr><tr><td>Sandwich Tests</td><td>Add unit tests for sandwich-related logic</td><td>opam switch, <code>opam switch</code>, <code>opam install</code>, <code>opam list</code>, <code>.opam</code> file, <code>melange-fest</code>, <code>open</code> module, <code>module_systems</code> field, punning, type inference</td></tr><tr><td>Cram Tests</td><td>Set up cram tests to run your unit tests</td><td>cram tests, <code>cram</code> stanza, Dune alias, promotion, test output sanitization, sandbox, <code>expand_aliases_in_sandbox</code> stanza</td></tr><tr><td>Burger Discounts</td><td>Implement burger discount logic using arrays</td><td>limits of type inference, type annotation of function arguments, full name (asset path), <code>Stdlib</code>, record spread syntax, <code>ignore</code>, runtime representations of common data types, properties of arrays, override <code>Array.get</code></td></tr><tr><td>Discounts Using Lists</td><td>Re-implement burger discount logic using lists</td><td>properties of lists, pattern matching on lists, list spread syntax, <code>List</code> module, <code>ListLabels</code> module, runtime representation of lists, documentation comments, placeholder operator</td></tr><tr><td>Promo Codes</td><td>Implement promo and discount logic using Result</td><td>built-in Result type, translating error message to Reason syntax, <code>List.iter</code>, for loops, polymorphic variants, runtime representations of Result and polymorphic variants</td></tr><tr><td>Promo Component</td><td>Create a promo component that renders Results using polymorphic variant</td><td>Documentation comment markup language, <code>React.useReducer</code>, <code>as</code> keyword to ignore arguments, <code>opam-check-npm-deps</code>, <code>Result.map</code>, render mutually-exclusive states using polymorphic variant constructors</td></tr></tbody></table><p>…and much more to come!</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>If the backend language isn’t OCaml, you can still share types between frontend and backend through a third-party tool like <a href="https://github.com/ahrefs/atd" target="_blank" rel="noreferrer">atd</a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Note that <a href="https://github.com/ml-in-barcelona/server-reason-react" target="_blank" rel="noreferrer">server-reason-react</a> is not yet polished. However, the parts of its API that are more stable are already used in production by <a href="https://ahrefs.com/" target="_blank" rel="noreferrer">Ahrefs</a>. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Because of the focus on ReasonReact, we won’t cover traditional OCaml syntax in this guide. Instead, we’ll cover the <a href="https://reasonml.github.io/" target="_blank" rel="noreferrer">Reason syntax</a> which works great with ReasonReact because of its first-class support for JSX. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>',15),s=[n];function i(d,c,l,h,u,p){return t(),o("div",null,s)}const g=e(r,[["render",i]]);export{f as __pageData,g as default};
